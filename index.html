<!DOCTYPE html>
<html>
    <head>
        <title>OTJS, Ryhmä Heikkinen</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="css/desert.css">
        <link rel="stylesheet" href="css/page.css">
        <script type="text/javascript" src="js/w1.js"></script>
        <script type="text/javascript" src="js/w2.js"></script>
        <script type="text/javascript" src="js/w1final.js"></script>
    </head>
<body>

    <h1>Jäsenet, ryhmä Heikkinen</h1>
    <ul>
        <li>Ville Heikkinen</li>
        <li>Jami Karvanen</li>
        <li>Jonne Airaksinen</li>
        <li>Markus Jantunen</li>
    </ul>
    <nav>
        <ul>
            <li><a href="#week1">Viikko1</a></li>
            <li><a href="#week2">Viikko2</a></li>
            <li><a href="#week3">Viikko3</a></li>
            <li><a href="#week4">Viikko4</a></li>
        </ul>
    </nav>

<blockquote>

<section class="weekly">
    <a name="week1"></a>
    <header>
        <h3>Viikko 1: Tyyppitarkistus JS-kirjasto</h3>
        <ul>
            <li><a href="w1tests.html">Vaatimukset (qUnit)</a></li>
            <li><a href="js/w1.js">Koodi</a></li>

        </ul>
    </header>
    <article>
        <p>Tyyppiturvallisuuden periaatteita:</p>
        <ul>
            <li>Tyyppitarkastukset olisi syytä suorittaa kaikissa funktioissa, jotka vastaanottavat parametreja</li>
            <li>Tarkastus tulisi suorittaa heti funktion ensimmäisenä käskynä</li>
            <li>Tyyppitarkistusluokan tulee heittää ainakin taulukoiden yhteydessä poikkeukset puuttuvista
                parametreistä, sillä luokan toiminta ei ole kovin johdonmukaista ilman niitä
            </li>
            <li>Muita tyyppejä kuin perustyyppejä (JS:n nimetyt luokat) ei ole mielekästä tarkistaa, sillä niiden
                kirjo on suuri ja niiden validiuden voi tarkistaa instanceOf() metodilla
            </li>
        </ul>
        <div class="row">
            <pre class="prettyprint code-half-page">
                <code id="w1">
                </code>
            </pre>
            <pre class="prettyprint code-half-page">
                <code id="w1tests">
                </code>
            </pre>
        </div>
    </article>
</section>
<section class="weekly">
    <a name="week2"></a>
    <header>
        <h3>Viikko 2 </h3>
    </header>
    <article>
        <p>Kaksoisparadigma, ohjelmointityylit, sulkeumat:</p>
        <ul>
            <li>JavaScriptillä on hyvä kirjoittaa koodia, joka sekoittaa sekä funktionaalista että perinteistä
                ohjelmointityyliä. Funktionaalisella koodilla on mahdollista tuottaa hyvin tiiviitä ja atomisia
                funktioita, jotka säästävät kirjoittamiselta ja pelastavat pandoja pitkällä tehtäimellä. Ks. esimerkit
                hyvin tiiviistä forEach ja map -kutsuista
            </li>
            <li>
                Tiivis koodityyli yhdistettynä virhekäsittelyyn helpottaa myöskin. Hyödynnämme esimerkiksi forEach-
                ja map-funktioissa viime viikon tyyppitarkistuskirjastoa, jota on laajennettu hieman tukemaan myös
                funktioiden tyyppitarkistusta hyvin tehokkaalla tavalla. <br><br>
                Virheenkäsittely pitäisi aina hoitaa "periyttämällä" virhetyypit Error-objektista, sillä kaikki
                eri JavaScript-tulkit osaavat virhekäsittelyn Try-catch -blockeissa tämän objektin instansseille.
                Virheitä voi antaa myös ilman Error-objektia, throw "this is an error", mutta se ei ole kovin suositeltavaa
                Internet Explorerin ymmärryksen takia.<br><br>
                Myös JavaScriptiin pätee: throw early, catch late. Ts. kaappaa virheet mahdollisimman matalalla tasolla
                kutsuketjuja saadaksesi mahdollisimman yksinkertaisen virheenkäsittelyrakenteen, heitä virheet heti kun
                niitä kohdataan. Tämä ohjaa koodin rakennetta järkevään suuntaan.
            </li>
            <li>
                ´               Sulkeuma on ensiluokkainen funktio, jolla on vapaita muuttujia sidottuna ympäristöönsä.
                Tähän alueeseen se on myös itse sidottu, ja sen muuttujat ovat olemassa ainakin yhtä pitkään kuin sulkeuma itse.
                Käytännössä ja helpommin ilmaistuna sulkeuma on siis funktio, joka on määritelty toisen näkyvyysalueen sisällä, josta pääsee muokkaamaan muuttujia ulommassa näkyvyysalueessa. Sulkeumat ovat hyödyllisiä mm. callback funktioissa. Esimerkiksi onClick.<br><br>
                Jos taas sulkeumafunktio päättyy, mutta itse sulkeuman muuttujat säilyvät on kyseessä eräänlainen kapselointi. Tällöin näihin funktion luomiin sulkeumamuuttujiin voidaan päästä käsiksi muuttujakohtaisilla "aksessori"funktioilla.

            </li>
        </ul>
        <div class="row">
            <pre class="prettyprint code-half-page">
                <code id="w2">
                </code>
            </pre>
            <pre class="prettyprint code-half-page">
                <code id="w2run">

                    var numbersArray = [1, 2, 3, 4, 5, 6, 7, 8];
                    var afterAddition = map(function (x) { return x + 1 }, numbersArray);
                    var afterMultiply = map(function (x) { return x * 2}, numbersArray);

                    <script>
                        var numbersArray = [1, 2, 3, 4, 5, 6, 7, 8];
                        var afterAddition = map(function (x) {
                            return x + 1;
                        }, numbersArray);
                        var afterMultiply = map(function (x) {
                            return x * 2;
                        }, numbersArray);
                    </script>
                    // Lisätään +1
                    <script>
                        document.write(afterAddition);
                    </script>
                    // Kerrotaan *2
                    <script>
                        document.write(afterMultiply);
                    </script>

                    var exNestedArray = [["one", "two"], ["foo", "bar"]];

                    // Tulosta jokainen taulukon elementti
                    forEach(exNestedArray, function(elem, index) { document.write(index + ": " + elem + " ")});
                    <script>
                        var exNestedArray = [
                            ["one", "two"],
                            ["foo", "bar"]
                        ];
                        forEach(exNestedArray, function(elem, index) { document.write(index + ": " + elem + " ")});
                    </script>

                    // Sisäkkäisten taulukoiden konkatenaatio
                    exNestedArray = map(concatenate, exNestedArray);
                    <script>
                        exNestedArray = map(concatenate, exNestedArray);
                        document.write(exNestedArray);

                    </script>

                    // Virhekäsittelyä
                    try {
                    map(concatenate, {1:"isnotanarray", 2:"isnotanarrayvalue"});
                    } catch(error) {
                    if(ex instanceof ArrayError) {
                    document.write("Caught an ArrayError: " + error.message);
                    } else {
                    document.write("Caught something else: " + error.message);
                    }
                    }
                    // Virhekäsittelyä
                    try {
                    map(1+1, exNestedArray);
                    } catch(error) {
                    if(ex instanceof ArrayError) {
                    document.write("Caught an ArrayError: " + error.message);
                    } else {
                    document.write("Caught something else: " + error.message);
                    }
                    }


                    // Pitäisi kaapata ArrayError
                    <script>
                        try {
                            map(concatenate, {1:"isnotanarray", 2:"isnotanarrayvalue"});
                        } catch(error) {
                            if(error instanceof ArrayError) {
                                document.write("Caught an ArrayError: " + error.message);
                            } else {
                                document.write("Caught something else: " + error.message);
                            }
                        }

                    </script>

                    // Pitäisi tuottaa TypeError
                    <script>
                        try {
                            map(1+1, exNestedArray);
                        } catch(error) {
                            if(error instanceof ArrayError) {
                                document.write("Caught an ArrayError: " + error.message);
                            } else {
                                document.write("Caught something else: " + error.message);
                            }
                        }

                    </script>

                    // Singleton counter example
                    function initNewCounter() {
                    var count = 0;
                    function nextCount() {
                    return ++count;
                    }
                    return nextCount;
                    }

                    var counter = initNewCounter();

                    document.write(counter());
                    document.write(counter());
                    document.write(counter());

                    <script>
                        function initNewCounter() {
                            var count = 0;
                            function nextCount() {
                                return ++count;
                            }
                            return nextCount;
                        }

                        var counter = initNewCounter("foo");

                        document.write(counter()+", ");
                        document.write(counter()+", ");
                        document.write(counter());

                    </script>
                </code>
            </pre>
        </div>
    </article>

</section>
<section class="weekly">
    <a name="week3"></a>
    <header>
        <h3>Viikko 3</h3>
    </header>
    <article>
        <p>Prototyyppiperintä on mun lempparijuttu</p>
        <p>Pointteja:</p>
        <ul>
            <li>Dynaamisuus (mikä tahansa objekti-instanssi on laajennettavissa)</li>
            <li>Perintäketju: olio voi periä ominaisuuksia koko "sukupuulta"</li>
        </ul>
    </article>
</section>
<section class="weekly">
    <a name="week4"></a>
    <header>
       <h3>Viikko 4</h3>
    </header>
    <article>
      <p>Tyyppiturvallisuuden periaatteita:</p>
        <ul>

            <li>Tyyppitarkastukset olisi syytä suorittaa kaikissa funktioissa, jotka vastaanottavat parametreja</li>
            <li>Tarkastus tulisi suorittaa heti funktion ensimmäisenä käskynä</li>
            <li>Tyyppitarkistusluokan tulee heittää ainakin taulukoiden yhteydessä poikkeukset puuttuvista
                parametreistä, sillä luokan toiminta ei ole kovin johdonmukaista ilman niitä
            </li>
            <li>Muita tyyppejä kuin perustyyppejä (JS:n nimetyt luokat) ei ole mielekästä tarkistaa, sillä niiden
                kirjo on suuri ja niiden validiuden voi tarkistaa instanceOf() metodilla
            </li>
        </ul>
    
        <div class="row">
            <pre class="prettyprint code-half-page">
                <code id="w1final">
                </code>
            </pre>
        </div>
    </article>
    <article>
        <p>Kaksoisparadigma, ohjelmointityylit, sulkeumat:</p>
        <ul>
            <li>JavaScriptillä on hyvä kirjoittaa koodia, joka sekoittaa sekä funktionaalista että perinteistä
                ohjelmointityyliä. Funktionaalisella koodilla on mahdollista tuottaa hyvin tiiviitä ja atomisia
                funktioita, jotka säästävät kirjoittamiselta ja pelastavat pandoja pitkällä tehtäimellä. Ks. esimerkit
                hyvin tiiviistä forEach ja map -kutsuista
            </li>
            <li>
                Tiivis koodityyli yhdistettynä virhekäsittelyyn helpottaa myöskin. Hyödynnämme esimerkiksi forEach-
                ja map-funktioissa viime viikon tyyppitarkistuskirjastoa, jota on laajennettu hieman tukemaan myös
                funktioiden tyyppitarkistusta hyvin tehokkaalla tavalla. <br><br>
                Virheenkäsittely pitäisi aina hoitaa "periyttämällä" virhetyypit Error-objektista, sillä kaikki
                eri JavaScript-tulkit osaavat virhekäsittelyn Try-catch -blockeissa tämän objektin instansseille.
                Virheitä voi antaa myös ilman Error-objektia, throw "this is an error", mutta se ei ole kovin suositeltavaa
                Internet Explorerin ymmärryksen takia.<br><br>
                Myös JavaScriptiin pätee: throw early, catch late. Ts. kaappaa virheet mahdollisimman matalalla tasolla
                kutsuketjuja saadaksesi mahdollisimman yksinkertaisen virheenkäsittelyrakenteen, heitä virheet heti kun
                niitä kohdataan. Tämä ohjaa koodin rakennetta järkevään suuntaan.
            </li>
            <li>
                ´               Sulkeuma on ensiluokkainen funktio, jolla on vapaita muuttujia sidottuna ympäristöönsä.
                Tähän alueeseen se on myös itse sidottu, ja sen muuttujat ovat olemassa ainakin yhtä pitkään kuin sulkeuma itse.
                Käytännössä ja helpommin ilmaistuna sulkeuma on siis funktio, joka on määritelty toisen näkyvyysalueen sisällä, josta pääsee muokkaamaan muuttujia ulommassa näkyvyysalueessa. Sulkeumat ovat hyödyllisiä mm. callback funktioissa. Esimerkiksi onClick.<br><br>
                Jos taas sulkeumafunktio päättyy, mutta itse sulkeuman muuttujat säilyvät on kyseessä eräänlainen kapselointi. Tällöin näihin funktion luomiin sulkeumamuuttujiin voidaan päästä käsiksi muuttujakohtaisilla "aksessori"funktioilla.

            </li>
        </ul>
        <div class="row">
            <pre class="prettyprint code-half-page">
                <code id="w2final">
                </code>
            </pre>
        </div>
    <p>JavaScriptin Oliot:</p>

    </article>
</section>
</blockquote>

<script type="text/javascript" src="js/prettify.js"></script>
<script type="text/javascript" src="lib/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="js/page.js"></script>


</body>
</html>
